#+TITLE: Emacs Configuration
#+AUTHOR: Alex Recker
#+EMAIL: alex@reckerfamily.com
#+OPTIONS: num:nil
#+STARTUP: showall noindent
#+PROPERTY: header-args :results none :tangle yes

* Info

Before you get into the heavy stuff, introduce yourself to emacs.
This is also a great way to practice setting options with lisp.  Use
the =setq= function to set a value.  With your cursor at the end of
the parenthesis, run =C-x C-e= to evaluate the expression and see the
results in the minibuffer.

#+begin_src emacs-lisp
  (setq user-full-name "Alex Recker")
  (setq user-mail-address "alex@reckerfamily.com")
#+end_src

If you want to see the current value of a variable, you can run =C-x
C-e= with the cursor placed directly over the text, or you can use
=describe-variable= from the =M-x= menu.

* Appearance

If you're getting used to Emacs, it would be a good idea to leave the
menu bar, tool bar, and scroll bar visible.  I hide them for maximum
screen real estate.

#+begin_src emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
#+end_src

Change the font to something that looks nice on the OS.  On mac, I
like Monaco.

#+begin_src emacs-lisp :tangle (if (string= system-type "darwin") "yes" "no")
  (set-frame-font "Monaco 18" nil t)
#+end_src

If running on Linux, you might want something like Monospace.

#+begin_src emacs-lisp :tangle (if (string= system-type "gnu/linux") "yes" "no")
  (set-frame-font "Monospace 13" nil t)
#+end_src

In each buffer, emacs displays the major and minor modes in the
modeline.  I like seeing the major mode, but the minor modes tend to
be the same long list of plugins, so I use a package to just hide
these.

#+begin_src emacs-lisp
  (use-package rich-minority
    :ensure t
    :init (rich-minority-mode 't)
    :config (setq rm-blacklist ""))
#+end_src

* Startup

Make sure the Emacs =PATH= is in sync with the user's shell =PATH=.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config (exec-path-from-shell-initialize))
#+end_src

By default, Emacs shows you a big, beautiful splash screen with a
bunch of helpful links.  I've seen this before, so I turn it off.

#+begin_src emacs-lisp
  (setq inhibit-splash-screen 't)
#+end_src

With the splash screen suppressed, Emacs uses the =*scratch*= buffer
as a home screen.  This is a convenient place to jot down notes and
try out lisp snippets, so add some configuration to make it more
comfy.  First, I add a callback to =kill-buffer= to always avoid
killing =*scratch*=.

#+begin_src emacs-lisp
  (defun recker/not-scratch-p ()
    "Return NIL if the current buffer is the *scratch* buffer."
    (not (equal (buffer-name (current-buffer)) "*scratch*")))

  (add-hook 'kill-buffer-query-functions 'recker/not-scratch-p)
#+end_src

Next, I customize the lisp comment at the top of the buffer to use the
output from a program.  This program copies pithy quotes from a little
stash I keep on my [[https://www.alexrecker.com/quotes.html][blog]], but you can easily replace this variable with
"fortune" or something else.

#+begin_src emacs-lisp
  (setq recker/scratch-message-command "fortune")

  (defun recker/scratch-message ()
    "Return a scratch message from fortune-blog."
    (with-temp-buffer
      (insert (shell-command-to-string recker/scratch-message-command))
      (let ((comment-start ";; "))
	(comment-region (point-min) (point-max)))
      (fill-individual-paragraphs (point-min) (point-max))
      (concat "\n" (buffer-string) "\n")))

  (setq initial-scratch-message (recker/scratch-message))
#+end_src

#+caption: the scratch buffer with a randomized, custom message.
[[./screenshots/scratch-message.png]]

* Movement

A subtle, but important tweak - if backspace or delete while you have
some text highlighted, delete the highlighted text.  That's what you
would expect it to do, right?

#+begin_src emacs-lisp
  (setq delete-selection-mode 't)
#+end_src

Enable this mode to make buffers automatically track changes made to
the underlying file and update the buffer real time.  If you're Emacs
is behaving slowly, I would try turning this off.

#+begin_src emacs-lisp
  (global-auto-revert-mode t)
#+end_src

Add some keybindings for functions I frequently use.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c l") 'sort-lines)
  (global-set-key (kbd "C-c r") 'replace-string)
#+end_src

Upcase a region without emacs bothering you about it.

#+begin_src emacs-lisp
  (put 'upcase-region 'disabled nil)
#+end_src

Use expand region to highlight incrementally larger sections of text.

#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :bind (("C-=" . 'er/expand-region)))
#+end_src

Enable IDO for minibuffer selections.  IDO is kind of a complicated
beast, but it allows you to move around so much more quickly.  So it's
best to just get used to Emacs with it enabled.

#+begin_src emacs-lisp
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (ido-mode t)
#+end_src

This package displays IDO results vertically rather than horizontally,
which feels a lot easier on the eyes.

#+begin_src emacs-lisp
  (use-package ido-vertical-mode
	       :ensure t
	       :config (setq ido-vertical-define-keys 'C-n-and-C-p-only)
	       :init (ido-vertical-mode))
#+end_src

#+caption: the find-file function operating with the helpful interactive IDO menu.
[[./screenshots/ido.png]]

Use IDO to power imenu.  Depending on the text or code you're
organizing, imenu lets you jump to functions, constants, and sections.

#+begin_src emacs-lisp
  (use-package idomenu
    :ensure t
    :bind ("C-c i" . idomenu))
#+end_src

#+caption: using imenu to browse sections of an org document.
[[./screenshots/imenu.png]]

Use smex as a more helpful alternative to =M-x=.

#+begin_src emacs-lisp
  (use-package smex
    :ensure t
    :init (smex-initialize)
    :bind (("M-x" . 'smex)
	   ("M-X" . 'smex-major-mode-commands)))
#+end_src

#+caption: filtering interactive commands with smex.
[[./screenshots/smex.png]]

Replace the default binding for =kill-buffer= with the much snappier
and succinct =kill-this-buffer=.

#+begin_src emacs-lisp emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
#+end_src

Sometimes I get overwhelmed and feel the need to rest Emacs by erasing
all buffers.  This function deletes everything.

#+begin_src emacs-lisp
  (defun recker/purge-buffers ()
    "Delete all buffers, except for *scratch*."
    (interactive)
    (mapc #'(lambda (b) (unless (string= (buffer-name b) "*scratch*") (kill-buffer b))) (buffer-list)))

  (global-set-key (kbd "C-x P") 'recker/purge-buffers)
#+end_src

Show autocompletion suggestions in all modes.

#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :init (add-hook 'after-init-hook 'global-company-mode))
#+end_src

#+caption: writing lisp with autocomplete suggestions.
[[./screenshots/company.png]]

Emacs comes with =isearch= and =isearch-backward= to precisely search
a buffer, but you can use the swiper package for quick, fuzzy results.

#+begin_src emacs-lisp
  (use-package swiper
    :ensure t
    :bind ("C-c s" . swiper))
#+end_src

#+caption: finding fuzzy results with siper.
[[./screenshots/swiper.png]]

Use projectile to search files within projects.

#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (setq projectile-completion-system 'ido)
    :init (projectile-mode t))
#+end_src

* Files

Follow symlinks around by default.

#+begin_src emacs-lisp
  (setq vc-follow-symlinks 't)
#+end_src

Don't automatically make backups of files - that's just kind of
annoying.

#+begin_src emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+end_src

Dired, the Emacs file manager, can help you manipulate local and
remote filesystems with ease.  Newer versions of =ls= support a
=--dired= flag, but who has ever even used a new version of =ls=?
Turn off this flag.

#+begin_src emacs-lisp
  (setq dired-use-ls-dired nil)
#+end_src

Dired gets the final word.  If I kill a file in Dired, don't bother me
about the associated buffer.

#+begin_src emacs-lisp
  (setq dired-clean-confirm-killing-deleted-buffers nil)
#+end_src

Hide hidden files by defult.  Press =C-x M-o= to show them.

#+begin_src emacs-lisp
  (require 'dired-x)
  (setq-default dired-omit-files-p t)
  (setq dired-omit-files (concat dired-omit-files "\\|^\\..+$"))
  (add-hook 'dired-mode-hook 'dired-omit-mode)
#+end_src

* Shell

Use =C-x t= to open a terminal window.

#+begin_src emacs-lisp
  (defun recker/ansi-term ()
    "Launch ansi-term with current shell."
    (interactive)
    (let ((shell (or (getenv "SHELL") "/bin/bash")))
      (ansi-term shell)))

  (global-set-key (kbd "C-x t") 'recker/ansi-term)
#+end_src

Use =C-c e= to open up eshell.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c e") 'eshell)
#+end_src

Automatically close the buffer when you exit the shell.

#+begin_src emacs-lisp
  (defun recker/handle-term-exit (&optional process-name msg)
    (message "%s | %s" process-name msg)
    (kill-buffer (current-buffer)))

  (advice-add 'term-handle-exit :after 'recker/handle-term-exit)
#+end_src

* Modes

In all modes, clean up whitespace on save.

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src

I heard a rumor that eglot is going to be included by default in the
next version of Emacs, so I may as well get used to it now.

#+begin_src emacs-lisp
  (use-package eglot
    :ensure t
    :config
    (setq eglot-autoshutdown 't)
    (setq eglot-autoreconnect nil)
    (setq eglot-confirm-server-initiated-edits nil))
#+end_src

I don't like to use these external language servers everywhere, but
they can be helpful for bigger spaces that would otherwise require a
lot of configuration and testing.

** Bats

#+begin_src emacs-lisp
  (use-package bats-mode
    :ensure t
    :mode ("\\.bats\\'"))
#+end_src

** C

Taken right from the Linux kernel standard (as if I'll ever need it
lol).

#+begin_src emacs-lisp
  (defun recker/c-lineup-arglist-tabs-only (ignored)
    "Line up argument lists by tabs, not spaces"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
	   (column (c-langelem-2nd-pos c-syntactic-element))
	   (offset (- (1+ column) anchor))
	   (steps (floor offset c-basic-offset)))
      (* (max steps 1)
	 c-basic-offset)))

  (defun recker/c-mode-hook ()
    (c-add-style
     "linux-tabs-only"
     '("linux" (c-offsets-alist
		(arglist-cont-nonempty
		 c-lineup-gcc-asm-reg
		 recker/c-lineup-arglist-tabs-only))))
    (setq indent-tabs-mode t)
    (setq show-trailing-whitespace t)
    (c-set-style "linux-tabs-only"))

  (add-hook 'c-mode-hook #'recker/c-mode-hook)
#+end_src

** D

#+begin_src emacs-lisp
  (use-package d-mode
    :ensure t
    :mode "\\.d\\'")
#+end_src

** Docker

#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :ensure t)
#+end_src

** Dhall

#+begin_src emacs-lisp
  (use-package dhall-mode
    :ensure t
    :mode "\\.dhall\\'"
    :config
    (setq dhall-format-at-save t
	  dhall-format-arguments (\` ("--ascii"))
	  dhall-use-header-line nil))
#+end_src

** Go

Install go-mode, just for the major mode.

#+begin_src emacs-lisp
  (use-package go-mode
    :ensure t)
#+end_src

For this to work out of the box, make sure =gopls= is executable somewhere.

#+begin_src shell
go install golang.org/x/tools/gopls@latest
#+end_src

Run the hook.

#+begin_src emacs-lisp
  (add-hook 'go-mode-hook 'eglot-ensure)
#+end_src

While editing go, run =gofmt= before each save.

#+begin_src emacs-lisp
  (defun recker/go-mode-hook ()
    (add-hook 'before-save-hook #'gofmt-before-save))

  (add-hook 'go-mode-hook 'recker/go-mode-hook)
#+end_src

** Groovy

#+begin_src emacs-lisp
  (use-package groovy-mode
    :ensure t
    :mode ("\\Jenkinsfile\\'" "\\.groovy\\'"))
#+end_src

** Haskell

#+begin_src emacs-lisp
  (use-package haskell-mode
    :ensure t
    :mode "\\.hs\\'")
#+end_src

** Jsonnet

#+begin_src emacs-lisp
  (use-package jsonnet-mode
    :ensure t
    :mode ("\\.jsonnet\\'" "\\.libsonnet\\'"))
#+end_src

** Lisp

#+begin_src emacs-lisp
  ;; TODO: busted?
  ;; (use-package slime
  ;;   :ensure t
  ;;   :config (setq inferior-lisp-program (executable-find "sbcl")))

  ;; (use-package slime-company
  ;;   :ensure t
  ;;   :after (slime company)
  ;;   :config (setq slime-company-completion 'fuzzy
  ;;		slime-company-after-completion 'slime-company-just-one-space))
#+end_src

** Lua

#+begin_src emacs-lisp
  (use-package lua-mode
    :ensure t
    :mode ("\\.lua\\'" "\\.p8\\'"))
#+end_src

** Nftables

#+begin_src emacs-lisp
  (use-package nftables-mode :ensure t)
#+end_src

** Nginx

#+begin_src emacs-lisp
  (use-package nginx-mode :ensure t)
#+end_src

** Python

Nothing!  I'm sick of tools, I just want to write python!

#+begin_src emacs-lisp
  (defun recker/python-mode-hook ()
    ;; disable fly* bullshit
    (flymake-mode -1)
    (flycheck-mode -1))

  (add-hook #'python-mode-hook #'recker/python-mode-hook)

  ;; comment this out to skip eglot
  (add-hook 'python-mode-hook 'eglot-ensure)
  (add-to-list 'eglot-server-programs '((python-mode) "jedi-language-server"))
#+end_src

** Rst

#+begin_src emacs-lisp
  (use-package rst
    :ensure t
    :mode (("\\.rst$" . rst-mode)))
#+end_src

** Ruby

Isn't it surprising that after five years writing Ruby at my job
/this/ is the only customization I have?

#+begin_src emacs-lisp
  (setq ruby-deep-indent-paren nil)
#+end_src

Eh, throw eglot in there - why not?  This will work if the solargraph
gem is installed on the interpreter.

#+begin_src emacs-lisp
  (add-hook 'ruby-mode-hook 'eglot-ensure)
#+end_src

** Terraform

#+begin_src emacs-lisp
  (use-package terraform-mode
    :ensure t)

  (use-package company-terraform
    :ensure t)
#+end_src

** YAML

#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode ("\\.yml\\'" "\\.yaml\\'"))
#+end_src

* Bookmarks

Emacs bookmarks are really handy.  To bookmark a visiting file or directory, press =C-x r m=.

This setting tells Emacs to save the file each time it changes.

#+begin_src emacs-lisp
  (setq bookmark-save-flag 1)
#+end_src

Use a custom function to jump to bookmark with IDO.

#+begin_src emacs-lisp
  (require 'bookmark)
  (require 'cl-lib)

  (defun recker/list-bookmarks ()
    "List all bookmarks in alphabetical order, and filter out the junk entries I don't care about."
    (let ((junk-entries '("org-capture-last-stored")))
      (sort (cl-remove-if #'(lambda (b) (member b junk-entries)) (bookmark-all-names)) #'string<)))

  (defun recker/ido-bookmark-jump (bookmark)
    "*Switch to bookmark BOOKMARK interactively using `ido'."
    (interactive (list (ido-completing-read "Bookmark: " (recker/list-bookmarks) nil t)))
    (bookmark-jump bookmark))

  (global-set-key (kbd "C-x r b") 'recker/ido-bookmark-jump)
#+end_src

* Tools

Set local auth file.

#+begin_src emacs-lisp
  (setq auth-sources (list (concat user-emacs-directory "authinfo.gpg")))
#+end_src

Use magit for managing git projects.

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-x g" . magit-status))
#+end_src

Use editorconfig to automatically pick up project settings.

#+begin_src emacs-lisp
  (use-package editorconfig
    :ensure t
    :config (editorconfig-mode 1))
#+end_src

Use yasnippet for robust text snippets.

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :init (yas-global-mode))
#+end_src

Use flycheck to highlight coding problems.

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))
#+end_src

Use flyspell to highlight spelling mistakes.

#+begin_src emacs-lisp
  (use-package flyspell
    :config (setq ispell-program-name (executable-find "ispell"))
    :init (add-hook 'text-mode-hook #'(lambda () (flyspell-mode 1))))
#+end_src

Write good mode.

#+begin_src emacs-lisp
  (use-package writegood-mode
    :ensure t
    :bind (("C-c w" . writegood-mode)))
#+end_src

Use rest client mode for debugging web endpoints.  I use a custom
function to launch the tool.

#+begin_src emacs-lisp
  (defun recker/restclient ()
    (interactive)
    "Launch restclient."
    (get-buffer-create "*restclient*")
    (switch-to-buffer "*restclient*")
    (restclient-mode))

  (use-package restclient
    :ensure t)
#+end_src

Start emacs server.  You can use =emacsclient= as for the =EDITOR=
environment variable to automatically connect to emacs.

#+begin_src emacs-lisp
  (server-start)
#+end_src

* Org

Fix yasnippet in org mode.

#+begin_src emacs-lisp
  (defun recker/fix-yas-in-org ()
    (setq-local yas-buffer-local-condition
		'(not (org-in-src-block-p t))))

  (add-hook 'org-mode-hook #'recker/fix-yas-in-org)
#+end_src

Don't mess with indenting

#+begin_src emacs-lisp
  (setq org-adapt-indentation nil)
#+end_src

Show lines between headings, even when they're folded up.

#+begin_src emacs-lisp
  (setq org-cycle-separator-lines -1)
#+end_src

Type =C-c C-j= to enter browse mode.  This setting prevents =i-search=
from automatically running when you type, which is a strange default.

#+begin_src emacs-lisp
  (setq org-goto-auto-isearch nil)
#+end_src

Turn on the clock for measuring how long it takes to do things.

#+begin_src emacs-lisp
  (setq org-clock-persist 'history)
  (org-clock-persistence-insinuate)
#+end_src

** Code

Add some templates for code blocks.

#+begin_src emacs-lisp
  (setq org-structure-template-alist '(("e" . "src emacs-lisp")
				       ("p" . "src python")
				       ("r" . "src ruby")
				       ("b" . "src bash")
				       ("x" . "example")))
#+end_src

Interactively add a source block by pressing =C-c C--=.

#+begin_src emacs-lisp
  (require 'org-tempo)
  (global-set-key (kbd "C-c C--") #'org-insert-structure-template)
#+end_src

Life is short - don't prompt while executing code blocks.

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

Use plantuml mode for generating diagrams.  The latest version of
plantuml should be downloaded to =~/.plantuml/plantuml.jar=.

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :ensure t
    :config (setq org-plantuml-jar-path "~/.plantuml/plantuml.jar")
    :init
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t))))
#+end_src

** Agenda

Look for tasks in all org files.

#+begin_src emacs-lisp
  (setq org-directory (expand-file-name "~/Dropbox/org"))
  (directory-files org-directory)
  (setq org-agenda-files `( ,org-directory ))
#+end_src

Use =C-c a= to open the org agenda view.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c a") 'org-agenda)
#+end_src

When moving around agenda, follow the corresponding items in notes.

#+begin_src emacs-lisp
  (setq org-agenda-start-with-follow-mode t)
#+end_src

Don't display archived items or tasks marked =DONE=.

#+begin_src emacs-lisp
  (setq org-agenda-skip-scheduled-if-done 't)
  (setq org-agenda-skip-deadline-if-done 't)
  (setq org-agenda-archives-mode nil)
#+end_src

Create some custom org agenda views.

#+begin_src emacs-lisp
  (setq org-agenda-custom-commands '())

  (setq recker/custom-agenda '("a" "agenda"
			       ((agenda "" ((org-deadline-warning-days 0)
					    (org-agenda-span 2))))))

  (add-to-list 'org-agenda-custom-commands recker/custom-agenda)
#+end_src

** Capture

Use =C-c c= to access the org capture menu.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c c") 'org-capture)
#+end_src

Define capture templates for quickly creating templated notes.

#+begin_src emacs-lisp
  (setq org-capture-templates '())
#+end_src

This is my catch all TODO snippet.

#+begin_src emacs-lisp
  (let ((opsat (concat org-directory "/opsat.org")))
    (add-to-list 'org-capture-templates
		 `("t" "Misc. TODO" entry (file ,opsat)
		   "* TODO %?\n" :empty-lines 1)))
#+end_src

** Publishing

If the htmlize package is installed, org mode will automatically apply
the appropriate syntax highlighting to code blocks when exporting to
HTML.

#+begin_src emacs-lisp
  (use-package htmlize :ensure t)
#+end_src

#+caption: Automatic syntax highlighting applied to a published org document.
[[./screenshots/htmlize.png]]

You can set up publishing projects here, but I don't have any at the moment.

#+begin_src emacs-lisp
  (setq org-publish-project-alist '())
#+end_src

* Gnus

Gnus is the charming and awkward mail/news/feed client built into
Emacs.  I use it to manage my personal email and keep up with feeds.

** Startup

I leave the primary select method empty, and I just define everything
as a secondary select method.

#+begin_src emacs-lisp
(setq gnus-select-method '(nnml ""))
(setq gnus-secondary-select-methods '())
#+end_src

Default to topic mode.

#+begin_src emacs-lisp
  (add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
#+end_src

Enable these powerful placebo options.

#+begin_src emacs-lisp
  (setq gnus-asynchronous t)
  (setq gnus-use-cache t)
  (setq gnus-check-new-newsgroups nil
	gnus-check-bogus-newsgroups nil)
  (setq gnus-show-threads nil
	gnus-use-cross-reference nil
	gnus-nov-is-evil nil)
  (setq gnus-check-new-newsgroups nil
	gnus-use-adaptive-scoring nil)
  (setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-23,23f%]%) %s
  ")
#+end_src

Don't dribble anywhere, that's gross.

#+begin_src emacs-lisp
(setq gnus-use-dribble-file nil)
#+end_src

Don't move archived messages anywhere.

#+begin_src emacs-lisp
(setq gnus-message-archive-group nil)
#+end_src

Use bbdb to store addresses.

#+begin_src emacs-lisp
  (use-package bbdb
    :ensure t
    :config (setq bbdb-file (concat user-emacs-directory "bbdb.el"))
    :init
    (bbdb-mua-auto-update-init 'message)
    (setq bbdb-mua-auto-update-p 'query)
    (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus))
#+end_src

** Email

Disable auto-fill mode when writing emails.

#+begin_src emacs-lisp
  (add-hook 'message-mode-hook #'turn-off-auto-fill)
#+end_src

Read with gmail's IMAP.

#+begin_src emacs-lisp
  (add-to-list 'gnus-secondary-select-methods
	       '(nnimap "alex@reckerfamily.com"
			(nnimap-address "imap.gmail.com")
			(nnimap-server-port "imaps")
			(nnimap-stream ssl)
			(nnmail-expiry-target "nnimap+alex@reckerfamily.com:[Gmail]/All Mail")
			(nnmail-expiry-wait immediate)))
#+end_src

Send email with SMTP.  These settings aren't directly tied to gnus.
In fact you can write and send an email anywhere from Emacs with =C-x
m=.

#+begin_src emacs-lisp
(setq smtpmail-smtp-service 587
      smtpmail-smtp-user "alex@reckerfamily.com"
      smtpmail-smtp-server "smtp.gmail.com"
      send-mail-function 'smtpmail-send-it)
#+end_src

* Functions

Open today's journal entry.

#+begin_src emacs-lisp
  (defun recker/today ()
    "Open today's journal entry."
    (interactive)
    (let* ((target
	    (format-time-string "~/src/blog/entries/%Y-%m-%d.html"))
	   (frontmatter
	    (format-time-string "<!-- meta:title -->\n<!-- meta:banner %Y-%m-%d.jpg -->\n\n")))
      (if (file-exists-p target)
	  (find-file target)
	(progn (find-file target)
	       (insert frontmatter)))))

  (global-set-key (kbd "C-c t") 'recker/today)
#+end_src

Add =<p>= tags to an HTML buffer (not quite perfect, but gets it
close).

#+begin_src emacs-lisp
  (defun recker/add-p-tags-to-buffer ()
    "Automatically wrap all paragraphs in buffer in <p></p> tags."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "\\(\\`\\|\n\n+\\)\\([^< $\n]\\)" nil t)
	(replace-match "\\1<p>\\2" t))
      (goto-char (point-min))
      (while (re-search-forward "\\([^>}\n]\\)\\(\n\n+\\|\n\\'\\)" nil t)
	(replace-match "\\1</p>\\2" t))))
#+end_src

Emacs has a =fill-region=, so why not an =unfill-region=?

#+begin_src emacs-lisp
  (defun recker/unfill-region (beg end)
    "Unfill the region, joining text paragraphs into a single logical line."
    (interactive "*r")
    (let ((fill-column (point-max)))
      (fill-region beg end)))
#+end_src
