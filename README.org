#+TITLE: Emacs Configuration
#+AUTHOR: Alex Recker

This is my emacs config.  It's very fancy, isn't it?  If you'd like to
use it, clone this repository in place as your new =~/.emacs.d=
directory.

#+BEGIN_EXAMPLE
  $ git clone https://github.com/arecker/emacs.d.git .emacs.d
#+END_EXAMPLE

* Personal
  
Make sure you change these variables.  Otherwise, you might confuse my
mother.
  
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Alex Recker"
	user-mail-address "alex@reckerfamily.com")
#+END_SRC

* Building

I like compiling my emacs from source.  If you are interested in doing
the same, this section is for your convencience.

#+BEGIN_EXAMPLE
  $ mkdir src && cd src
  $ git clone -b master git://git.sv.gnu.org/emacs.git && cd emacs
  $ git checkout [tag or commit]
  $ ./autogen.sh
  $ ./configure  # supply --with-ns if on OSX
  $ make
  $ sudo make install
#+END_EXAMPLE

* Packages

All extra things are retrieved by this config with the help of
[[https://github.com/jwiegley/use-package][use-package]].  Sadly, since that code needs to run before anything is
tangled, it cannot live in this document.  See [[file:init.el][init.el]] for the package
initialization portion.

* Startup

This package does a nice job ensuring the =PATH= variable is synced
up.  OSX is the only OS that misbehaves, but here it is nonetheless.

** Path

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :config (exec-path-from-shell-initialize))
#+END_SRC

** Scratch

The slash screen displayed on startup is a little too noisy for me.
The =*scratch*= buffer is a lot more low key.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message 't)
#+END_SRC

This function replaces the generic =;; This buffer is for text...=
comment with something more interesting.

#+BEGIN_SRC emacs-lisp
  (setq recker/scratch-message-program "fortune")

  (defun recker/get-startup-scratch ()
    (with-temp-buffer (lisp-mode)
                      (insert-string (shell-command-to-string recker/scratch-message-program))
                      (comment-region (point-max) (point-min))
                      (buffer-string)))

  (setq initial-scratch-message (recker/get-startup-scratch))
#+END_SRC

Make it un-dead!

#+BEGIN_SRC emacs-lisp
  (use-package unkillable-scratch
    :ensure t
    :init (unkillable-scratch))
#+END_SRC

* Interface

** Better Defaults
   
Emacs comes with some obnixious defaults.

#+BEGIN_SRC emacs-lisp
  (setq backup-inhibited t
	auto-save-default 0
	indent-tabs-mode nil)
#+END_SRC

** Better Look

Remove the scrollbar, tool bar, and menu bar.

#+BEGIN_SRC emacs-lisp
  (defun recker/emacs-startup-hook ()
    (menu-bar-mode 0)
    (tool-bar-mode 0)
    (toggle-scroll-bar 0))
  (add-hook 'emacs-startup-hook 'recker/emacs-startup-hook)
#+END_SRC

Make the default font something prettier, like [[http://levien.com/type/myfonts/inconsolata.html][inconsolata]].

#+BEGIN_SRC emacs-lisp
  (set-default-font "Inconsolata Medium 11")
  (set-default-font "Monospace 10")
#+END_SRC

Load a good theme.

#+BEGIN_SRC emacs-lisp
  (use-package zenburn-theme
    :ensure t
    :init (load-theme 'zenburn t))
#+END_SRC

** Better Comments

I overwrite the build-in =comment-dwim= with its superior sequel.

#+BEGIN_SRC emacs-lisp
  (use-package comment-dwim-2
    :ensure t
    :bind ("M-;" . comment-dwim-2))
#+END_SRC

** Better Modeline

#+BEGIN_SRC emacs-lisp
  (use-package rich-minority
    :ensure t
    :init (rich-minority-mode 1)
    :config (setq rm-blacklist ""))
#+END_SRC

** Better Text Selection

I use =expand-region= to incrementally grab larger portions of text
based on where the cursor is.  It's a brilliant tool.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-=" . er/expand-region))
#+END_SRC

Also, if text is entered while text is highlighted, it should
overwrite it.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC

** Better Git

Magit.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-x g" . magit-status))
#+END_SRC

** Better Completion

Completion and filtering with ivy, supported by counsel.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :config
    (ivy-mode 1))

  (use-package counsel
    :ensure t
    :bind
    ("C-c i" . counsel-imenu)
    ("C-c s" . swiper))
#+END_SRC

And actual auto-complete.

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :init (ac-config-default)) 
#+END_SRC

* Modes

These are the settings for various editing modes - the top level being
"text-mode", which is for /editing text written for humans to read/.

Inferior modes should disable these at when it makes sense to.

#+BEGIN_SRC emacs-lisp
  (defun recker/text-mode-hook ()
    (auto-fill-mode 1)
    (flyspell-mode 1)
    (flymake-mode-off))
  (add-hook 'text-mode-hook 'recker/text-mode-hook)
#+END_SRC

Since I find myself alphabetizing text files often, I like to bind
=sort-lines= to something convenient.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c l") 'sort-lines)
#+END_SRC

Flycheck mode.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init
    (global-flycheck-mode))
#+END_SRC

Globally cleanup white space on save.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace-cleanup-mode
    :ensure t
    :config (global-whitespace-cleanup-mode))
#+END_SRC

** JavaScript

This is the web-scale portion of my config.

#+BEGIN_SRC emacs-lisp
  (setq js-indent-level 2)
#+END_SRC

** Ruby
   
These are very much a work in progress.  I know about as much about
ruby as I know about scented candles and professional football.

#+BEGIN_SRC emacs-lisp
  (setq ruby-deep-indent-paren nil)
#+END_SRC

** Terminal

I'm a simple man, and I use a simple shell.

#+BEGIN_SRC emacs-lisp
  (defun recker/ansi-term ()
    (interactive)
    (ansi-term "/bin/bash"))
  (global-set-key (kbd "C-c e") 'eshell)
  (global-set-key (kbd "C-x t") 'recker/ansi-term)
#+END_SRC

The terminal buffer should be killed on exit.
   
#+BEGIN_SRC emacs-lisp
  (defadvice term-handle-exit
      (after term-kill-buffer-on-exit activate)
    (kill-buffer))
#+END_SRC

** YAML

YAML is so hip and cool.

#+BEGIN_SRC emacs-lisp
  (use-package flymake-yaml
    :ensure t)

  (use-package indent-guide
    :ensure t)

  (use-package yaml-mode
    :ensure t
    :mode ("\\.yml\\'" "\\.sls\\'")
    :init
    (add-hook 'yaml-mode-hook 'turn-off-auto-fill)
    (add-hook 'yaml-mode-hook 'flymake-yaml-load)
    (add-hook 'yaml-mode-hook 'indent-guide-mode))
#+END_SRC

* Org

Org is love.  Org is life.

** General

#+BEGIN_SRC emacs-lisp
  (use-package "org"
    :ensure t
    :pin "org"
    :init (add-hook 'org-mode-hook 'org-indent-mode)
    :config (org-babel-do-load-languages
             'org-babel-load-languages
             '((python . t)
               (lisp . t)
               (ditaa . t)
               (ruby . t)
               (sh . t)
               (java . t)
               (js . t)
               (C . t)))
    :bind (("C-c a" . org-agenda)
           ("C-c c" . org-capture)))
#+END_SRC

** Blog

My [[https://alexrecker.com/][blog]] is generated from 100% org mode publishing.  For any of this
to work, the project needs to be cloned to =~/git/blog=.  But that's
/my/ blog, so there's no reason you would need to publish a copy of
it, right?  It's not like you are a psycho who would do that, right?

*** Dependencies

Use this package to make source pretty.  Or just leave the CSS classes
in case I want to add a theme some day.

#+BEGIN_SRC emacs-lisp
  (use-package "htmlize"
    :ensure t
    :config (setq org-html-htmlize-output-type 'css))
#+END_SRC

Also, I need the rss publishing function found in this package.  It
doesn't play well with org mode.  May have to =org-reload= and clear
out your =elpa= folder a few times.

#+BEGIN_SRC emacs-lisp
  (use-package "org-plus-contrib"
    :ensure t
    :pin "org")
#+END_SRC

*** Partials

#+NAME: preamble
#+BEGIN_EXAMPLE
  <nav>
    <a href="/index.html">Home</a>
     <div style="float: right;">
      <a href="./pdfs/slug.pdf">PDF</a>
      &nbsp;&nbsp;
      <a href="./txt/slug.txt">TXT</a>
    </div>
  </nav>
#+END_EXAMPLE

#+NAME: comments
#+BEGIN_EXAMPLE
  <div id="disqus_thread"></div>
  <script>
   (function() {
       var d = document, s = d.createElement('script');
       s.src = '//alexrecker.disqus.com/embed.js';
       s.setAttribute('data-timestamp', +new Date());
       (d.head || d.body).appendChild(s);
   })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript" rel="nofollow">
    comments powered by Disqus.
    </a>
  </noscript>
#+END_EXAMPLE

#+NAME: analytics
#+BEGIN_EXAMPLE
  <script>
   (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
   })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
   ga('create', 'UA-42540208-6', 'alexrecker.com');
   ga('send', 'pageview');
  </script>
#+END_EXAMPLE

#+NAME: head-extra
#+BEGIN_EXAMPLE
  <link rel="stylesheet" href="./css/lora.css" />
  <link rel="stylesheet" href="./css/site.css" />
  <script type="text/javascript" src="/js/app.js"></script>
#+END_EXAMPLE

*** Environments

Initialize the publishing a list.

#+BEGIN_SRC emacs-lisp
  (setq-default org-publish-project-alist '())
#+END_SRC

This function will generate the publishing components.

#+BEGIN_SRC emacs-lisp :var comments=comments analytics=analytics head-extra=head-extra preamble=preamble
  (defun recker/add-blog-project (suffix pubdir analyticsp commentsp)
    (let ((comments (if commentsp comments nil))
          (analytics (if analyticsp analytics nil)))

      ;; index
      (add-to-list 'org-publish-project-alist
                   `(,(concat "blog-index-" suffix)
                     :base-directory "~/git/blog"
                     :exclude ".*"
                     :html-doctype "html5"
                     :html-head-extra ,(concat head-extra)
                     :html-postamble ,(concat analytics)
                     :include ("index.org")
                     :publishing-directory ,(concat pubdir)
                     :publishing-function org-html-publish-to-html
                     :section-numbers nil
                     :with-tags nil
                     :with-toc nil
                     ))

      ;; posts
      (add-to-list 'org-publish-project-alist
                   `(,(concat "blog-posts-" suffix)
                     :base-directory "~/git/blog"
                     :base-extension "org"
                     :exclude "index.org\\|README.org"
                     :html-doctype "html5"
                     :html-head-extra ,(concat head-extra)
                     :html-preamble (lambda (options)
                                      (let ((slug (file-name-base (buffer-file-name))))
                                        (replace-regexp-in-string "slug" slug ,(concat preamble))))
                     :html-postamble ,(concat comments analytics)
                     :publishing-directory ,(concat pubdir)
                     :publishing-function org-html-publish-to-html
                     :recursive t
                     :section-numbers nil
                     :with-toc nil
                     ))

      ;; posts-pdf
      (add-to-list 'org-publish-project-alist
                   `(,(concat "blog-posts-pdf-" suffix)
                     :base-directory "~/git/blog"
                     :base-extension "org"
                     :exclude "index.org\\|README.org"
                     :publishing-directory ,(concat pubdir "/pdfs")
                     :publishing-function org-latex-publish-to-pdf
                     :recursive t
                     :section-numbers nil
                     :with-toc nil
                     ))

      ;; posts-txt
      (add-to-list 'org-publish-project-alist
                   `(,(concat "blog-posts-txt-" suffix)
                     :base-directory "~/git/blog"
                     :base-extension "org"
                     :exclude "index.org\\|README.org"
                     :publishing-directory ,(concat pubdir "/txt")
                     :publishing-function org-ascii-publish-to-ascii
                     :recursive t
                     :section-numbers nil
                     :with-toc nil
                     ))

      ;; posts-static
      (add-to-list 'org-publish-project-alist
                   `(,(concat "blog-static-" suffix)
                     :base-directory "~/git/blog"
                     :base-extension "txt\\|css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
                     :publishing-directory ,(concat pubdir)
                     :publishing-function org-publish-attachment
                     :recursive t
                     ))

      ;; rss
      (add-to-list 'org-publish-project-alist
                   `(,(concat "blog-rss-" suffix)
                     :base-directory "~/git/blog"
                     :base-extension "org"
                     :exclude ".*"
                     :exclude-tags ("noexport" "norss")
                     :include ("index.org")
                     :html-link-home "http://alexrecker.com"
                     :html-link-use-abs-url t
                     :publishing-directory ,(concat pubdir "/feed/")
                     :publishing-function (org-rss-publish-to-rss)
                     ))

      ;; everything
      (add-to-list 'org-publish-project-alist
                   `(,(concat "blog-" suffix)
                     :components ,(mapcar (lambda (p) (concat p "-" suffix))
                                          '("blog-index"
                                            "blog-posts"
                                            "blog-posts-pdf"
                                            "blog-posts-txt"
                                            "blog-static"
                                            "blog-rss"))))))


  (recker/add-blog-project "testing" "/tmp/testing.alexrecker.com" nil nil)
  (recker/add-blog-project "production" "/tmp/alexrecker.com" 't 't)
#+END_SRC

* Functions

These are miscellaneous functions that I've written (or plagiarized).

#+BEGIN_SRC emacs-lisp
  (defun recker/purge-buffers ()
    "Deletes all buffers except for *scratch*"
    (interactive)
    (let ((kill-if-not-scratch
           (lambda (b)
             (unless (string= (buffer-name b) "*scratch*")
               (kill-buffer b)))))
      (mapc kill-if-not-scratch (buffer-list))))

  (defun recker/load-file-if-exists (file)
    (let ((path (expand-file-name file)))
      (if (file-exists-p path)
	  (load-file path))))

  (defun recker/unfill-region (beg end)
    "Unfill the region, joining text paragraphs into a single
              logical line.  This is useful, e.g., for use with
              `visual-line-mode'."
    (interactive "*r")
    (let ((fill-column (point-max)))
      (fill-region beg end)))

  (defun recker/run-current-file ()
    "Execute or compile the current file.
  For example, if the current buffer is the file x.pl,
  then it'll call “perl x.pl” in a shell.
  The file can be php, perl, python, ruby, javascript, bash, ocaml, vb, elisp.
  File suffix is used to determine what program to run.
  If the file is modified, ask if you want to save first. (This command always run the saved version.)
  If the file is emacs lisp, run the byte compiled version if exist."
    (interactive)
    (let (suffixMap fName fSuffix progName cmdStr)

      ;; a keyed list of file suffix to comand-line program path/name
      (setq suffixMap 
            '(("php" . "php")
              ;; ("coffee" . "coffee -p")
              ("pl" . "perl")
              ("py" . "python")
              ("rb" . "ruby")
              ("js" . "node")             ; node.js
              ("sh" . "bash")
              ("ml" . "ocaml")
              ("vbs" . "cscript")))
      (setq fName (buffer-file-name))
      (setq fSuffix (file-name-extension fName))
      (setq progName (cdr (assoc fSuffix suffixMap)))
      (setq cmdStr (concat progName " \""   fName "\""))

      (when (buffer-modified-p)
	(progn 
          (when (y-or-n-p "Buffer modified. Do you want to save first?")
            (save-buffer) ) ) )

      (if (string-equal fSuffix "el") ; special case for emacs lisp
          (progn 
            (load (file-name-sans-extension fName)))
	(if progName
            (progn
              (message "Running…")
              ;; (message progName)
              (shell-command cmdStr "*run-current-file output*" ))
          (message "No recognized program file suffix for this file.")))
      ))

  (defun recker/org-scratch ()
    "Open a org mode *scratch* pad."
    (interactive)
    (switch-to-buffer "*org scratch*")
    (org-mode)
    (insert "#+TITLE: Org Scratch")
    (newline)
    (newline))
#+END_SRC

Likewise, miscellaneous key-bindings.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c b") 'browse-url)
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
  (global-set-key (kbd "C-x C-k k") 'kill-buffer)
  (global-set-key (kbd "C-c o") 'recker/org-scratch)
#+END_SRC

* Local

For any secrets or lispy changes you are testing out for the day, I
find it conenvient to keep those [[file:lisp/][here]].  This function loads all =.el=
files found there.

#+BEGIN_SRC emacs-lisp
  (defun recker/load-directory (dir)
    (let ((load-it (lambda (f)
                     (load-file (concat (file-name-as-directory dir) f)))
                   ))
      (mapc load-it (directory-files dir nil "\\.el$"))))
  (recker/load-directory "~/.emacs.d/lisp/")
#+END_SRC
