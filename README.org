#+TITLE: Emacs Configuration
#+AUTHOR: Alex Recker
#+OPTIONS: num:nil
#+STARTUP: showall
#+PROPERTY: header-args :results none

#+begin_src emacs-lisp
  (defun recker/path (dir &optional subpath)
    "Build a path name relative to the home directory."
    (let ((dir (file-name-as-directory (cl-getf recker/path-aliases dir (format "~/%s" dir))))
          (subpath (or subpath "")))
      (concat dir subpath)))
#+end_src

You can set your own aliases by overriding or appending
=recker/paths-aliases=.

#+begin_src emacs-lisp
  (setq recker/path-aliases
        '(:home "~"
          :desktop "~/desktop"
          :docs "~/docs"
          :pics "~/pics"
          :public "~/public"
          :src "~/src"
          :emacs "~/.emacs.d"))
#+end_src

Or it might look like this on a mac.

#+begin_src emacs-lisp
  (if (string-equal system-type "darwin")
      (setq recker/path-aliases
            '(:home "~"
              :desktop "~/Desktop"
              :docs "~/Documents"
              :pics "~/Pictures"
              :public "~/Public"
              :src "~/src"
              :emacs "~/.emacs.d")))
#+end_src

* Interface

By default, emacs will display the major mode as well as all active
minor modes in the modeline.  I think it clutters up the file
information so I use this nifty plugin to hide it all.  Only the major
mode is displayed.

#+BEGIN_SRC emacs-lisp
(use-package rich-minority
  :ensure t
  :init (rich-minority-mode 1)
  :config (setq rm-blacklist ""))
#+END_SRC

* Buffers

Purge all buffers with =C-x P=.

#+begin_src emacs-lisp
  (defun recker/purge-buffers ()
    "Delete all buffers, except for *scratch*."
    (interactive)
    (mapc #'(lambda (b) (unless (string= (buffer-name b) "*scratch*") (kill-buffer b))) (buffer-list)))
(global-set-key (kbd "C-x P") 'recker/purge-buffers)
#+end_src

Kill buffers without confirming.

#+begin_src emacs-lisp
(global-set-key (kbd "C-x C-k k") 'kill-buffer)
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+end_src

* Files

Don't automatically make backup files.

#+begin_src emacs-lisp
(setq make-backup-files nil
      auto-save-default nil)
#+end_src

Automatically revert buffer if file changes.

#+begin_src emacs-lisp
(global-auto-revert-mode 1)
#+end_src

Configure **dired**, the emacs file manager.

#+begin_src emacs-lisp
(require 'dired-x)
(setq-default dired-omit-files-p t)
(setq dired-omit-files (concat dired-omit-files "\\|^\\..+$"))
(setq dired-listing-switches "-lah")
(setq dired-use-ls-dired nil)
(setq dired-clean-confirm-killing-deleted-buffers nil)
#+end_src

Map a few file registers.

#+begin_src emacs-lisp
  (set-register ?b `(file . ,(recker/path :src "blog")))
  (set-register ?c '(file . "/ssh:laptop:/home/alex"))
  (set-register ?d `(file . ,(recker/path :desktop)))
  (set-register ?a `(file . ,(recker/path :docs "archive.org")))
  (set-register ?w `(file . ,(recker/path :docs "work.org")))
  (set-register ?j `(file . ,(recker/path :docs "journal.org")))
  (set-register ?i `(file . ,(recker/path :docs "ideas.org")))
  (set-register ?j `(file . ,(recker/path :docs "mixtape.org")))
  (set-register ?e `(file . ,(recker/path :emacs "README.org")))
  (set-register ?l `(file . ,(recker/path :emacs "local.el")))
  (set-register ?n '(file . "/ssh:alex@nas.local:/volume1/homes/alex/"))
#+end_src

Configure bookmarks.

#+begin_src emacs-lisp
(require 'bookmark)
(setq bookmark-save-flag 1
      bookmark-default-file (recker/path :docs "emacs/bookmarks.el"))

(defun recker/ido-bookmark-jump (bookmark)
  "*Switch to bookmark BOOKMARK interactively using `ido'."
  (interactive (list (ido-completing-read "Bookmark: " (bookmark-all-names) nil t)))
  (bookmark-jump bookmark))

(global-set-key (kbd "C-x r b") 'recker/ido-bookmark-jump)
#+end_src

Search files within a project with projectile mode.

#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :config
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (setq projectile-completion-system 'ivy)
  :init (projectile-mode t))
#+end_src

* Version Control

Follow symlinks.

#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC

Magit is a wonderful plugin.  Honestly, it just gets it so right with
the quick, intuitive interface.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind
  ("C-x g" . magit-status)
  ("C-c m" . magit-blame))
#+END_SRC

* Tools

Dictionary

#+begin_src emacs-lisp
(use-package dictionary :ensure t)
#+end_src

_SWIPER NO SWIPING_.

#+begin_src emacs-lisp
(use-package swiper
  :ensure t
  :bind ("C-c s" . swiper))
#+end_src

Incrementally select intelligent portions of text the with
=expand-region= shortcut.

#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("C-=" . er/expand-region))
#+end_src

Flycheck for angry red squiggles.

#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :init
  (global-flycheck-mode))
#+end_src

Install yasnippet.

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :init (yas-global-mode))
#+end_src

* Passwords

I use the =pass= tool for personal secret management.  It's my own
crummy implementation.

#+begin_src emacs-lisp
(defun recker/pass-directory ()
  (or (bound-and-true-p recker/active-pass-directory)
      (expand-file-name "~/.password-store")))

(defun recker/pass--file-to-entry (path)
  (file-name-sans-extension
   (file-relative-name path (recker/pass-directory))))

(defun recker/pass-list-entries ()
  (mapcar
   #'recker/pass--file-to-entry
   (directory-files-recursively (recker/pass-directory) ".gpg")))

(defun recker/pass-to-string (path)
  (cl-first
   (split-string
    (shell-command-to-string
     (format "PASSWORD_STORE_DIR=\"%s\" pass \"%s\" | head -1" (recker/pass-directory) path))
    "\n")))

(defun recker/pass-to-clip (path)
  (interactive (list (completing-read "Password: " (recker/pass-list-entries) nil t)))
  (shell-command
   (format "PASSWORD_STORE_DIR=\"%s\" pass -c \"%s\"" (recker/pass-directory) path)))

(defun recker/pass-to-clip-work ()
  (interactive)
  (let ((recker/active-pass-directory (expand-file-name "~/.password-store-work")))
    (funcall-interactively #'recker/pass-to-clip (completing-read "Password: " (recker/pass-list-entries) nil t))))

(global-set-key (kbd "C-x p") 'recker/pass-to-clip)
(global-set-key (kbd "C-x w") 'recker/pass-to-clip-work)
#+end_src

* Terminal

Use bash for launching a terminal and bind my custom wrapper function
to =C-x t=.

#+begin_src emacs-lisp
(defun recker/ansi-term ()
  (interactive)
  (ansi-term "/bin/bash"))

(global-set-key (kbd "C-x t") 'recker/ansi-term)
#+end_src

On exiting a terminal, also kill the buffer.

#+begin_src emacs-lisp
(defadvice term-handle-exit
    (after term-kill-buffer-on-exit activate)
  (kill-buffer))
#+end_src

Eshell too.

#+begin_src emacs-lisp
(global-set-key (kbd "C-c e") 'eshell)
#+end_src

* Major Modes

** HTML

Some custom HTML writing functions.  I'll probably move them to
yasnippet once I can figure it out.

#+begin_src emacs-lisp
(defun recker/filename-to-alt (filename)
  "Convert a filepath to an HTML alt attribute."
  (let ((name (file-name-sans-extension filename))
        (chars '(?_ ?- ?/)))
    (dolist (char chars)
      (setf name (subst-char-in-string char ?\s name)))
    name))

(defun recker/insert-figure (filename caption)
  "Insert an HTML figure and caption."
  (interactive "sFilename:
sCaption: ")
  (message "%s" caption)
  (let* ((src (format "/images/%s" filename))
         (alt (recker/filename-to-alt filename))
         (img (format "<a href=\"%s\">\n<img alt=\"%s\" src=\"%s\"/>\n</a>" src alt src))
         (figcaption (if (not (string-equal caption ""))
                         (format "<figcaption>\n<p>%s</p>\n</figcaption>" caption))))
    (insert
     (if (string-equal caption "")
         (format "<figure>\n%s\n</figure>" img)
       (format "<figure>\n%s\n%s\n</figure>" img figcaption)))))
#+end_src

** Markdown

Markdown, bleh.

#+begin_src emacs-lisp
(use-package markdown-mode
  :ensure t
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+end_src

** reStructuredText

I intend to give [[https://docutils.sourceforge.io/rst.html][reStructuredText]] a serious try someday, it looks
pretty cool.

#+begin_src emacs-lisp
  (use-package rst
    :ensure t
    :defer t
    :mode (("\\.rst$" . rst-mode)))
#+end_src

** Text

Clean up white space on save.

#+begin_src emacs-lisp
(add-hook 'before-save-hook 'whitespace-cleanup)
#+end_src

Configure spellcheck.

#+begin_src emacs-lisp
(setq ispell-personal-dictionary (recker/path :docs "emacs/ispell.dict"))
(setq ispell-program-name (executable-find "ispell"))
(add-hook 'text-mode-hook #'(lambda () (flyspell-mode t)))
#+end_src

Auto-fill text while writing, and check spelling of course.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-auto-fill)
(add-hook 'gfm-mode-hook 'turn-on-auto-fill)
(add-hook 'rst-mode-hook 'turn-on-auto-fill)
#+end_src

The =write-good= package so I can learn to write more gooder.

#+begin_src emacs-lisp
(use-package writegood-mode
  :ensure t
  :defer t
  :init
  (add-hook 'org-mode-hook 'writegood-mode)
  (add-hook 'gfm-mode-hook 'writegood-mode))
#+end_src

** YAML

I hate being a YAML engineer it's awesome.

#+begin_src emacs-lisp
(use-package yaml-mode
  :ensure t
  :defer t
  :mode ("\\.yml\\'" "\\.yaml\\'"))
#+end_src

* Org

Make sure =org-tempo= is loaded so shortcuts work for code blocks, I
guess.  This is a recent workaround.

#+begin_src emacs-lisp
(require 'org-tempo)
#+end_src

Run **code blocks** interactively without the confirmation prompt each
time.  Set up some languages.

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((java . t)
     (perl . t)
     (python . t)
     (ruby . t)
     (shell . t)))
#+end_src

Deft for searching org notes.

#+begin_src emacs-lisp
  (use-package deft
    :ensure t
    :config
    (setq deft-extensions '("org"))
    (setq deft-directory (recker/path :docs))
    (setq deft-recursive t)
    (setq deft-auto-save-interval 0)
    :init
    (global-set-key (kbd "C-c o") 'deft)
    (global-set-key (kbd "C-c n") 'deft-find-file))
#+end_src

Don't mess with indentation or empty lines.

#+begin_src emacs-lisp
  (setq org-adapt-indentation nil)
  (setq org-cycle-separator-lines -1)
#+end_src

Fix yasnippet in org mode.

#+begin_src emacs-lisp
  (defun recker/fix-yas-in-org ()
    (setq-local yas-buffer-local-condition
                '(not (org-in-src-block-p t))))
  (add-hook 'org-mode-hook #'recker/fix-yas-in-org)
#+end_src

[[https://plantuml.com/emacs][Plantuml]] integration.  Make sure you download the [[https://plantuml.com/download][JAR file]] and save it
to =~/.plantuml/plantuml.jar=.

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :ensure t
    :config (setq org-plantuml-jar-path (recker/path :home ".plantuml/plantuml.jar"))
    :init
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t))))
#+end_src

Re-render images after executing code blocks.

#+begin_src emacs-lisp
  (defun recker/org-rerender-images ()
    (when org-inline-image-overlays
      (org-redisplay-inline-images)))

  (add-hook 'org-babel-after-execute-hook #'recker/org-rerender-images)
#+end_src

Configure **capture templates** and map the selector to =C-c c=.

#+begin_src emacs-lisp
  (setq org-capture-templates '())
  (global-set-key (kbd "C-c c") 'org-capture)

  (add-to-list 'org-capture-templates
               `("j" "journal entry" plain (file+olp+datetree ,(recker/path :docs "journal.org")) "%?\n"
                 :empty-lines-before 1 :empty-lines-after 1))

  (add-to-list 'org-capture-templates
               `("m" "mixtape notes" plain (file+olp+datetree ,(recker/path :docs "mixtape.org")) "%?\n"
                 :empty-lines-before 1 :empty-lines-after 1))

  (add-to-list 'org-capture-templates
               `("i" "idea" plain (file+olp+datetree ,(recker/path :docs "ideas.org")) "%?\n"
                 :empty-lines-before 1 :empty-lines-after 1))

  (add-to-list 'org-capture-templates
               `("p" "productivity task" entry (file+headline ,(recker/path :docs "opsat.org") "Productivity") "* TODO %?\n"))

  (add-to-list 'org-capture-templates
               `("w" "work task" entry (file ,(recker/path :docs "work.org")) "* TODO %?\n"))
#+end_src

Configure **agenda** and set up and map the view to =C-c a=.

#+begin_src emacs-lisp
(setq org-agenda-files (list (recker/path :docs)))
(setq org-directory (list (recker/path :docs)))
(setq org-agenda-start-with-follow-mode t)
(global-set-key (kbd "C-c a") 'org-agenda)
(setq org-agenda-tag-filter-preset '("-ARCHIVE"))
#+end_src

Configure **attachments**.

#+begin_src emacs-lisp
(setq org-attach-directory (recker/path :docs "attachments/"))
(setq org-attach-archive-delete 't)
#+end_src

Configure **publish projects**.

#+begin_src emacs-lisp
(setq org-publish-project-alist '())
#+end_src

Install htmlize for sweet snyntax highlighting on HTML exports.

#+begin_src emacs-lisp
(use-package htmlize :ensure t)
#+end_src

Open up a new blog post.

#+begin_src emacs-lisp
  (defun recker/today ()
    "Open today's journal entry."
    (interactive)
    (let* ((target
            (recker/path :src (format-time-string "blog/_posts/%Y-%m-%d-entry.md")))
           (frontmatter
            (format-time-string "---\ntitle:\nbanner: %Y-%m-%d.jpg\n---\n\n")))
      (if (file-exists-p target)
          (find-file target)
        (progn (find-file target)
               (insert frontmatter)))))
  (global-set-key (kbd "C-c t") 'recker/today)
#+end_src

Don't show archived or done items in the agenda.

#+begin_src emacs-lisp
  (setq org-agenda-skip-scheduled-if-done t
        org-agenda-skip-deadline-if-done  t
        org-agenda-archives-mode nil)
#+end_src

Don't automatically search in =org-goto=.

#+begin_src emacs-lisp
  (setq org-goto-auto-isearch nil)
#+end_src

* Gnus

Odd, but fulfilling.  Here is my sordid configuration.  Set up some
empty primary and secondary methods.

#+begin_src emacs-lisp
(setq gnus-select-method '(nnml ""))
(setq gnus-secondary-select-methods '())
#+end_src

Use topic mode by default.

#+begin_src emacs-lisp
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
#+end_src

Hide startup files and directories in my documents.

#+begin_src emacs-lisp
(setq gnus-startup-file (recker/path :docs "emacs/newsrc"))
(setq gnus-home-directory (recker/path :docs "emacs/gnus")
      nnfolder-directory (recker/path :docs "emacs/gnus/Mail/archive")
      message-directory (recker/path :docs "emacs/gnus/Mail")
      nndraft-directory (recker/path :docs "emacs/gnus/Drafts")
      gnus-cache-directory (recker/path :docs "emacs/gnus/cache"))
#+end_src

Enable the powerful placebo options.

#+begin_src emacs-lisp
  (setq gnus-asynchronous t)
  (setq gnus-use-cache t)
  (setq gnus-check-new-newsgroups nil
        gnus-check-bogus-newsgroups nil)
  (setq gnus-show-threads nil
        gnus-use-cross-reference nil
        gnus-nov-is-evil nil)
  (setq gnus-check-new-newsgroups nil
        gnus-use-adaptive-scoring nil)
  (setq gnus-summary-line-format "%U%R%z%I%(%[%4L: %-23,23f%]%) %s
")
#+end_src

Don't dribble anywhere, that's gross.

#+begin_src emacs-lisp
(setq gnus-use-dribble-file nil)
#+end_src

Don't move archived messages anywhere.

#+begin_src emacs-lisp
(setq gnus-message-archive-group nil)
#+end_src

Use bbdb to store addresses.

#+begin_src emacs-lisp
(use-package bbdb
  :ensure t
  :config (setq bbdb-file (recker/path :docs "emacs/bbdb.el"))
  :init
  (bbdb-mua-auto-update-init 'message)
  (setq bbdb-mua-auto-update-p 'query)
  (add-hook 'gnus-startup-hook 'bbdb-insinuate-gnus))
#+end_src

Configure **imap** settings.

#+begin_src emacs-lisp
  (setq gnus-secondary-select-methods '())
  (add-to-list 'gnus-secondary-select-methods
               '(nnimap "alex@reckerfamily.com"
                        (nnimap-address "imap.gmail.com")
                        (nnimap-server-port "imaps")
                        (nnimap-stream ssl)
                        (nnmail-expiry-target "nnimap+alex@reckerfamily.com:[Gmail]/All Mail")
                        (nnmail-expiry-wait immediate)))
  (add-to-list 'gnus-secondary-select-methods
               '(nnimap "arecker@zendesk.com"
                        (nnimap-user "arecker@zendesk.com")
                        (nnimap-address "imap.gmail.com")
                        (nnimap-server-port "imaps")
                        (nnimap-stream ssl)
                        (nnmail-expiry-target "nnimap+arecker@zendesk.com:[Gmail]/All Mail")
                        (nnmail-expiry-wait immediate)))
#+end_src

Configure **smtp** settings.

#+begin_src emacs-lisp
(setq smtpmail-smtp-service 587
      smtpmail-smtp-user "alex@reckerfamily.com"
      smtpmail-smtp-server "smtp.gmail.com"
      send-mail-function 'smtpmail-send-it)
#+end_src

* Mail

Use mstp to send mail (handles multiple accounts).

#+begin_src emacs-lisp
  (setq message-send-mail-function 'message-send-mail-with-sendmail)
  (setq sendmail-program "msmtp")
  (setq mail-host-address "smtp.gmail.com")
  (setq message-sendmail-f-is-evil 't)
  (setq message-sendmail-extra-arguments '("--read-envelope-from"))
#+end_src

* Functions

Rebind keys to some helpful existing functions.

#+begin_src emacs-lisp
(global-set-key (kbd "C-c r") 'replace-string)
(global-set-key (kbd "C-c l") 'sort-lines)
#+end_src

Some other helpful functions.

#+begin_src emacs-lisp
  (defun recker/unfill-region (beg end)
    "Unfill the region, joining text paragraphs into a single logical line."
    (interactive "*r")
    (let ((fill-column (point-max)))
      (fill-region beg end)))

  (defun recker/docs-sync ()
    (interactive)
    (let ((command (format "git-sync -d %s" (recker/path :docs))))
      (call-process-shell-command command nil "*docs-sync*" t))
    (message "docs-sync: successful"))
  (global-set-key (kbd "C-c d") 'recker/docs-sync)
#+end_src

* Local

Finally, load any local overrides if they exist..

#+begin_src emacs-lisp
  (let ((local-path (recker/path :emacs "local.el")))
    (if (file-exists-p local-path)
        (load-file local-path)))
#+end_src
